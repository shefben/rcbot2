#ifndef RCBOT_PLUGIN_H
#define RCBOT_PLUGIN_H

#ifdef _WIN32
#pragma once
#endif

// Conceptual Source SDK includes - actual paths/names might vary
#include "public/eiface.h"           // For IServerPluginCallbacks, CreateInterfaceFn, PLUGIN_RESULT
// #include "public/edict.h"         // For edict_t - usually part of eiface.h or a base header
#include "public/engine/iserverplugin.h" // For PLUGIN_INTERFACE_VERSION (might be in eiface.h too)
// #include "public/tier1/interface.h" // For EXPOSE_SINGLE_INTERFACE_GLOBALVAR (if used)

// Standard library includes
#include <vector>
#include <map>    // Though m_ManagedBots is now a vector, map might be useful elsewhere
#include <string>
#include <memory> // For std::unique_ptr

// Project headers
#include "BotTasks.h" // For CUserCmd forward declaration if it's simple struct, or other task related enums
                      // If CUserCmd is complex from SDK, BotTasks.h might not need to fwd declare it.

// Forward declarations for classes used as members or parameters
class CFFBaseAI;
class CObjectivePlanner;
struct BotKnowledgeBase; // Typically defined in FFBaseAI.h or its own header
struct ClassConfigInfo;  // Typically defined in FFStateStructs.h
// struct edict_t; // Already in eiface.h typically
// struct CUserCmd; // Forward declare if not in BotTasks.h or SDK include

// Structure to hold info about managed bots
struct BotInfo {
    edict_t* pEdict;    // Pointer to game entity, set on ClientPutInServer
    int botId;          // Unique ID for the bot, generated by the plugin
    std::string name;
    int teamId;         // Requested/Assigned Team ID (e.g., 2 for RED, 3 for BLUE)
    std::string classNameRequest; // Requested Class Name (e.g., "Soldier")
    int internalClassId; // Game-specific class ID resolved from classNameRequest

    std::unique_ptr<CFFBaseAI> aiModule;
    std::unique_ptr<CObjectivePlanner> objectivePlanner;

    bool isActive;      // True if bot is fully initialized and running AI
    bool isPendingSpawn; // True if bot slot requested, waiting for ClientPutInServer to provide edict

    BotInfo(int id, const std::string& botName, int team, const std::string& clsName)
        : pEdict(nullptr), botId(id), name(botName), teamId(team), classNameRequest(clsName),
          internalClassId(0), aiModule(nullptr), objectivePlanner(nullptr),
          isActive(false), isPendingSpawn(true) {}

    // Move constructor and assignment for vector management
    BotInfo(BotInfo&& other) noexcept = default;
    BotInfo& operator=(BotInfo&& other) noexcept = default;

    // Prevent copying due to unique_ptrs
    BotInfo(const BotInfo&) = delete;
    BotInfo& operator=(const BotInfo&) = delete;
};

class CRCBotPlugin : public IServerPluginCallbacks {
public:
    CRCBotPlugin();
    virtual ~CRCBotPlugin();

    // IServerPluginCallbacks methods
    virtual bool Load(CreateInterfaceFn interfaceFactory, CreateInterfaceFn gameServerFactory);
    virtual void Unload();
    virtual void Pause();
    virtual void UnPause();
    virtual const char *GetPluginDescription();
    virtual void LevelInit(char const *pMapName);
    virtual void ServerActivate(edict_t *pEdictList, int edictCount, int clientMax);
    virtual void GameFrame(bool simulating);
    // virtual void GameFrame(bool simulating, bool bFirstTick, bool bLastTick); // Use if target engine uses this signature
    virtual void LevelShutdown();
    virtual void ClientActive(edict_t *pEntity); // After client has been validated and is ready to spawn.
    virtual void ClientDisconnect(edict_t *pEntity);
    virtual void ClientPutInServer(edict_t *pEntity, char const *playername);
    virtual void SetCommandClient(int index); // Client index for a command
    virtual void ClientSettingsChanged(edict_t *pEdict); // Client changed name, team, etc.
    virtual PLUGIN_RESULT ClientConnect(bool *bAllowConnect, edict_t *pEntity, const char *pszName, const char *pszAddress, char *reject, int maxrejectlen);
    // const CCommand& args is typical for Source 1. Source 2 might use void* or other.
    // For this conceptual task, using const void* to avoid needing CCommand definition here.
    virtual PLUGIN_RESULT ClientCommand(edict_t *pEntity, const void*& args /* const CCommand &args */);
    virtual PLUGIN_RESULT NetworkIDValidated(const char *pszUserName, const char *pszNetworkID);
    virtual void OnQueryCvarValueFinished(int iCookie /* QueryCvarCookie_t */, edict_t *pPlayerEntity, int eStatus /* EQueryCvarValueStatus */, const char *pCvarName, const char *pCvarValue);
    virtual void OnEdictAllocated(edict_t *edict);
    virtual void OnEdictFreed(const edict_t *edict);
    // virtual IPluginCommon *GetPluginCommon() { return nullptr; } // If required by specific SDK version

    // Bot Management
    // Returns botId if successful request, -1 otherwise. Skill is conceptual.
    int RequestBot(const std::string& name, int teamId, const std::string& className, int skill = 1);
    // Finalizes bot setup once its edict is known (called from ClientPutInServer)
    void FinalizeBotAddition(edict_t* pBotEdict, const std::string& botName, int teamId, const std::string& className, int skill);
    // Removes a bot by its edict (called from ClientDisconnect or a kick command)
    void RemoveBot(edict_t* pBotEdict);
    void UpdateAllBots(); // Iterates m_ManagedBots and calls their AI Update

private:
    std::vector<BotInfo> m_ManagedBots; // Stores active and pending bot instances.
    int m_NextBotIdCounter;             // For generating unique bot IDs.
    // Pending bots could be identified within m_ManagedBots by isPendingSpawn flag and null pEdict.
    // std::vector<BotInfo> m_PendingBots; // Removed in favor of flags in m_ManagedBots' BotInfo

    // Conceptual: Store engine interfaces obtained in Load()
    // IVEngineServer* m_pEngineServer;
    // IPlayerInfoManager* m_pPlayerInfoManager; // For player info
    // IServerGameClients* m_pServerGameClients; // For iterating clients
    // IBotManager* m_pBotManager; // For CreateFakeClient or similar if engine provides
    // ICvar* m_pCvar; // For console variables

    // Conceptual: Global game state data, potentially loaded from Lua
    // std::unique_ptr<BotKnowledgeBase> m_pGlobalKnowledgeBase;
    // std::vector<ClassConfigInfo> m_GlobalClassConfigs;

    // Conceptual: Lua state and bridge functions
    // lua_State* m_pLuaState;
    // bool InitializeLuaBridge(const char* currentMapName);
    // void ShutdownLuaBridge();
    // void RegisterLuaFunctionsWithPlugin();

    // Helper to find a BotInfo by edict
    BotInfo* GetBotInfoByEdict(edict_t* pEdict);
};

// Required for EXPOSE_SINGLE_INTERFACE_GLOBALVAR if used
// extern CRCBotPlugin g_CRCBotPlugin;

#endif // RCBOT_PLUGIN_H
